// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mynigma.proto

#ifndef PROTOBUF_mynigma_2eproto__INCLUDED
#define PROTOBUF_mynigma_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mynigma {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mynigma_2eproto();
void protobuf_AssignDesc_mynigma_2eproto();
void protobuf_ShutdownFile_mynigma_2eproto();

class keyIntroduction;
class encrSessionKeyEntry;
class versionData;
class HMACData;
class encryptedData;
class signedData;
class payloadPart;
class payloadPart_emailRecipient;
class payloadPart_fileAttachment;

enum payloadPart_addresseeType {
  payloadPart_addresseeType_T_FROM = 0,
  payloadPart_addresseeType_T_REPLY_TO = 1,
  payloadPart_addresseeType_T_TO = 2,
  payloadPart_addresseeType_T_CC = 3,
  payloadPart_addresseeType_T_BCC = 4
};
bool payloadPart_addresseeType_IsValid(int value);
const payloadPart_addresseeType payloadPart_addresseeType_addresseeType_MIN = payloadPart_addresseeType_T_FROM;
const payloadPart_addresseeType payloadPart_addresseeType_addresseeType_MAX = payloadPart_addresseeType_T_BCC;
const int payloadPart_addresseeType_addresseeType_ARRAYSIZE = payloadPart_addresseeType_addresseeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* payloadPart_addresseeType_descriptor();
inline const ::std::string& payloadPart_addresseeType_Name(payloadPart_addresseeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    payloadPart_addresseeType_descriptor(), value);
}
inline bool payloadPart_addresseeType_Parse(
    const ::std::string& name, payloadPart_addresseeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<payloadPart_addresseeType>(
    payloadPart_addresseeType_descriptor(), name, value);
}
// ===================================================================

class keyIntroduction : public ::google::protobuf::Message {
 public:
  keyIntroduction();
  virtual ~keyIntroduction();

  keyIntroduction(const keyIntroduction& from);

  inline keyIntroduction& operator=(const keyIntroduction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const keyIntroduction& default_instance();

  void Swap(keyIntroduction* other);

  // implements Message ----------------------------------------------

  keyIntroduction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const keyIntroduction& from);
  void MergeFrom(const keyIntroduction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oldKeyLabel = 1;
  inline bool has_oldkeylabel() const;
  inline void clear_oldkeylabel();
  static const int kOldKeyLabelFieldNumber = 1;
  inline const ::std::string& oldkeylabel() const;
  inline void set_oldkeylabel(const ::std::string& value);
  inline void set_oldkeylabel(const char* value);
  inline void set_oldkeylabel(const char* value, size_t size);
  inline ::std::string* mutable_oldkeylabel();
  inline ::std::string* release_oldkeylabel();
  inline void set_allocated_oldkeylabel(::std::string* oldkeylabel);

  // required string newKeyLabel = 2;
  inline bool has_newkeylabel() const;
  inline void clear_newkeylabel();
  static const int kNewKeyLabelFieldNumber = 2;
  inline const ::std::string& newkeylabel() const;
  inline void set_newkeylabel(const ::std::string& value);
  inline void set_newkeylabel(const char* value);
  inline void set_newkeylabel(const char* value, size_t size);
  inline ::std::string* mutable_newkeylabel();
  inline ::std::string* release_newkeylabel();
  inline void set_allocated_newkeylabel(::std::string* newkeylabel);

  // required bytes newEncKey = 3;
  inline bool has_newenckey() const;
  inline void clear_newenckey();
  static const int kNewEncKeyFieldNumber = 3;
  inline const ::std::string& newenckey() const;
  inline void set_newenckey(const ::std::string& value);
  inline void set_newenckey(const char* value);
  inline void set_newenckey(const void* value, size_t size);
  inline ::std::string* mutable_newenckey();
  inline ::std::string* release_newenckey();
  inline void set_allocated_newenckey(::std::string* newenckey);

  // required bytes newVerKey = 4;
  inline bool has_newverkey() const;
  inline void clear_newverkey();
  static const int kNewVerKeyFieldNumber = 4;
  inline const ::std::string& newverkey() const;
  inline void set_newverkey(const ::std::string& value);
  inline void set_newverkey(const char* value);
  inline void set_newverkey(const void* value, size_t size);
  inline ::std::string* mutable_newverkey();
  inline ::std::string* release_newverkey();
  inline void set_allocated_newverkey(::std::string* newverkey);

  // optional bytes signature = 5;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 5;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional int32 dateSigned = 7;
  inline bool has_datesigned() const;
  inline void clear_datesigned();
  static const int kDateSignedFieldNumber = 7;
  inline ::google::protobuf::int32 datesigned() const;
  inline void set_datesigned(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mynigma.keyIntroduction)
 private:
  inline void set_has_oldkeylabel();
  inline void clear_has_oldkeylabel();
  inline void set_has_newkeylabel();
  inline void clear_has_newkeylabel();
  inline void set_has_newenckey();
  inline void clear_has_newenckey();
  inline void set_has_newverkey();
  inline void clear_has_newverkey();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_datesigned();
  inline void clear_has_datesigned();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* oldkeylabel_;
  ::std::string* newkeylabel_;
  ::std::string* newenckey_;
  ::std::string* newverkey_;
  ::std::string* signature_;
  ::std::string* version_;
  ::google::protobuf::int32 datesigned_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static keyIntroduction* default_instance_;
};
// -------------------------------------------------------------------

class encrSessionKeyEntry : public ::google::protobuf::Message {
 public:
  encrSessionKeyEntry();
  virtual ~encrSessionKeyEntry();

  encrSessionKeyEntry(const encrSessionKeyEntry& from);

  inline encrSessionKeyEntry& operator=(const encrSessionKeyEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const encrSessionKeyEntry& default_instance();

  void Swap(encrSessionKeyEntry* other);

  // implements Message ----------------------------------------------

  encrSessionKeyEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const encrSessionKeyEntry& from);
  void MergeFrom(const encrSessionKeyEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyLabel = 1;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 1;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // required bytes encrSessionKey = 2;
  inline bool has_encrsessionkey() const;
  inline void clear_encrsessionkey();
  static const int kEncrSessionKeyFieldNumber = 2;
  inline const ::std::string& encrsessionkey() const;
  inline void set_encrsessionkey(const ::std::string& value);
  inline void set_encrsessionkey(const char* value);
  inline void set_encrsessionkey(const void* value, size_t size);
  inline ::std::string* mutable_encrsessionkey();
  inline ::std::string* release_encrsessionkey();
  inline void set_allocated_encrsessionkey(::std::string* encrsessionkey);

  // optional bytes introductionData = 3;
  inline bool has_introductiondata() const;
  inline void clear_introductiondata();
  static const int kIntroductionDataFieldNumber = 3;
  inline const ::std::string& introductiondata() const;
  inline void set_introductiondata(const ::std::string& value);
  inline void set_introductiondata(const char* value);
  inline void set_introductiondata(const void* value, size_t size);
  inline ::std::string* mutable_introductiondata();
  inline ::std::string* release_introductiondata();
  inline void set_allocated_introductiondata(::std::string* introductiondata);

  // @@protoc_insertion_point(class_scope:mynigma.encrSessionKeyEntry)
 private:
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_encrsessionkey();
  inline void clear_has_encrsessionkey();
  inline void set_has_introductiondata();
  inline void clear_has_introductiondata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keylabel_;
  ::std::string* encrsessionkey_;
  ::std::string* introductiondata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static encrSessionKeyEntry* default_instance_;
};
// -------------------------------------------------------------------

class versionData : public ::google::protobuf::Message {
 public:
  versionData();
  virtual ~versionData();

  versionData(const versionData& from);

  inline versionData& operator=(const versionData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const versionData& default_instance();

  void Swap(versionData* other);

  // implements Message ----------------------------------------------

  versionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const versionData& from);
  void MergeFrom(const versionData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.versionData)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static versionData* default_instance_;
};
// -------------------------------------------------------------------

class HMACData : public ::google::protobuf::Message {
 public:
  HMACData();
  virtual ~HMACData();

  HMACData(const HMACData& from);

  inline HMACData& operator=(const HMACData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HMACData& default_instance();

  void Swap(HMACData* other);

  // implements Message ----------------------------------------------

  HMACData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HMACData& from);
  void MergeFrom(const HMACData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encryptedData = 1;
  inline bool has_encrypteddata() const;
  inline void clear_encrypteddata();
  static const int kEncryptedDataFieldNumber = 1;
  inline const ::std::string& encrypteddata() const;
  inline void set_encrypteddata(const ::std::string& value);
  inline void set_encrypteddata(const char* value);
  inline void set_encrypteddata(const void* value, size_t size);
  inline ::std::string* mutable_encrypteddata();
  inline ::std::string* release_encrypteddata();
  inline void set_allocated_encrypteddata(::std::string* encrypteddata);

  // required bytes HMAC = 2;
  inline bool has_hmac() const;
  inline void clear_hmac();
  static const int kHMACFieldNumber = 2;
  inline const ::std::string& hmac() const;
  inline void set_hmac(const ::std::string& value);
  inline void set_hmac(const char* value);
  inline void set_hmac(const void* value, size_t size);
  inline ::std::string* mutable_hmac();
  inline ::std::string* release_hmac();
  inline void set_allocated_hmac(::std::string* hmac);

  // required string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.HMACData)
 private:
  inline void set_has_encrypteddata();
  inline void clear_has_encrypteddata();
  inline void set_has_hmac();
  inline void clear_has_hmac();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encrypteddata_;
  ::std::string* hmac_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static HMACData* default_instance_;
};
// -------------------------------------------------------------------

class encryptedData : public ::google::protobuf::Message {
 public:
  encryptedData();
  virtual ~encryptedData();

  encryptedData(const encryptedData& from);

  inline encryptedData& operator=(const encryptedData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const encryptedData& default_instance();

  void Swap(encryptedData* other);

  // implements Message ----------------------------------------------

  encryptedData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const encryptedData& from);
  void MergeFrom(const encryptedData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encrMessageData = 1;
  inline bool has_encrmessagedata() const;
  inline void clear_encrmessagedata();
  static const int kEncrMessageDataFieldNumber = 1;
  inline const ::std::string& encrmessagedata() const;
  inline void set_encrmessagedata(const ::std::string& value);
  inline void set_encrmessagedata(const char* value);
  inline void set_encrmessagedata(const void* value, size_t size);
  inline ::std::string* mutable_encrmessagedata();
  inline ::std::string* release_encrmessagedata();
  inline void set_allocated_encrmessagedata(::std::string* encrmessagedata);

  // repeated .mynigma.encrSessionKeyEntry encrSessionKeyTable = 2;
  inline int encrsessionkeytable_size() const;
  inline void clear_encrsessionkeytable();
  static const int kEncrSessionKeyTableFieldNumber = 2;
  inline const ::mynigma::encrSessionKeyEntry& encrsessionkeytable(int index) const;
  inline ::mynigma::encrSessionKeyEntry* mutable_encrsessionkeytable(int index);
  inline ::mynigma::encrSessionKeyEntry* add_encrsessionkeytable();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::encrSessionKeyEntry >&
      encrsessionkeytable() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::encrSessionKeyEntry >*
      mutable_encrsessionkeytable();

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string info = 4;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 4;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // repeated bytes encrAttachmentData = 5;
  inline int encrattachmentdata_size() const;
  inline void clear_encrattachmentdata();
  static const int kEncrAttachmentDataFieldNumber = 5;
  inline const ::std::string& encrattachmentdata(int index) const;
  inline ::std::string* mutable_encrattachmentdata(int index);
  inline void set_encrattachmentdata(int index, const ::std::string& value);
  inline void set_encrattachmentdata(int index, const char* value);
  inline void set_encrattachmentdata(int index, const void* value, size_t size);
  inline ::std::string* add_encrattachmentdata();
  inline void add_encrattachmentdata(const ::std::string& value);
  inline void add_encrattachmentdata(const char* value);
  inline void add_encrattachmentdata(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& encrattachmentdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_encrattachmentdata();

  // repeated bytes attachmentsHMAC = 6;
  inline int attachmentshmac_size() const;
  inline void clear_attachmentshmac();
  static const int kAttachmentsHMACFieldNumber = 6;
  inline const ::std::string& attachmentshmac(int index) const;
  inline ::std::string* mutable_attachmentshmac(int index);
  inline void set_attachmentshmac(int index, const ::std::string& value);
  inline void set_attachmentshmac(int index, const char* value);
  inline void set_attachmentshmac(int index, const void* value, size_t size);
  inline ::std::string* add_attachmentshmac();
  inline void add_attachmentshmac(const ::std::string& value);
  inline void add_attachmentshmac(const char* value);
  inline void add_attachmentshmac(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attachmentshmac() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attachmentshmac();

  // optional bytes messageHMAC = 7;
  inline bool has_messagehmac() const;
  inline void clear_messagehmac();
  static const int kMessageHMACFieldNumber = 7;
  inline const ::std::string& messagehmac() const;
  inline void set_messagehmac(const ::std::string& value);
  inline void set_messagehmac(const char* value);
  inline void set_messagehmac(const void* value, size_t size);
  inline ::std::string* mutable_messagehmac();
  inline ::std::string* release_messagehmac();
  inline void set_allocated_messagehmac(::std::string* messagehmac);

  // @@protoc_insertion_point(class_scope:mynigma.encryptedData)
 private:
  inline void set_has_encrmessagedata();
  inline void clear_has_encrmessagedata();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_messagehmac();
  inline void clear_has_messagehmac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encrmessagedata_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::encrSessionKeyEntry > encrsessionkeytable_;
  ::std::string* version_;
  ::std::string* info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> encrattachmentdata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attachmentshmac_;
  ::std::string* messagehmac_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static encryptedData* default_instance_;
};
// -------------------------------------------------------------------

class signedData : public ::google::protobuf::Message {
 public:
  signedData();
  virtual ~signedData();

  signedData(const signedData& from);

  inline signedData& operator=(const signedData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const signedData& default_instance();

  void Swap(signedData* other);

  // implements Message ----------------------------------------------

  signedData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const signedData& from);
  void MergeFrom(const signedData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyLabel = 1;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 1;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.signedData)
 private:
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keylabel_;
  ::std::string* signature_;
  ::std::string* data_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static signedData* default_instance_;
};
// -------------------------------------------------------------------

class payloadPart_emailRecipient : public ::google::protobuf::Message {
 public:
  payloadPart_emailRecipient();
  virtual ~payloadPart_emailRecipient();

  payloadPart_emailRecipient(const payloadPart_emailRecipient& from);

  inline payloadPart_emailRecipient& operator=(const payloadPart_emailRecipient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const payloadPart_emailRecipient& default_instance();

  void Swap(payloadPart_emailRecipient* other);

  // implements Message ----------------------------------------------

  payloadPart_emailRecipient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const payloadPart_emailRecipient& from);
  void MergeFrom(const payloadPart_emailRecipient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional .mynigma.payloadPart.addresseeType type = 3 [default = T_TO];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::mynigma::payloadPart_addresseeType type() const;
  inline void set_type(::mynigma::payloadPart_addresseeType value);

  // @@protoc_insertion_point(class_scope:mynigma.payloadPart.emailRecipient)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* email_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static payloadPart_emailRecipient* default_instance_;
};
// -------------------------------------------------------------------

class payloadPart_fileAttachment : public ::google::protobuf::Message {
 public:
  payloadPart_fileAttachment();
  virtual ~payloadPart_fileAttachment();

  payloadPart_fileAttachment(const payloadPart_fileAttachment& from);

  inline payloadPart_fileAttachment& operator=(const payloadPart_fileAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const payloadPart_fileAttachment& default_instance();

  void Swap(payloadPart_fileAttachment* other);

  // implements Message ----------------------------------------------

  payloadPart_fileAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const payloadPart_fileAttachment& from);
  void MergeFrom(const payloadPart_fileAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string contentID = 2;
  inline bool has_contentid() const;
  inline void clear_contentid();
  static const int kContentIDFieldNumber = 2;
  inline const ::std::string& contentid() const;
  inline void set_contentid(const ::std::string& value);
  inline void set_contentid(const char* value);
  inline void set_contentid(const char* value, size_t size);
  inline ::std::string* mutable_contentid();
  inline ::std::string* release_contentid();
  inline void set_allocated_contentid(::std::string* contentid);

  // optional int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional bytes hashedValue = 4;
  inline bool has_hashedvalue() const;
  inline void clear_hashedvalue();
  static const int kHashedValueFieldNumber = 4;
  inline const ::std::string& hashedvalue() const;
  inline void set_hashedvalue(const ::std::string& value);
  inline void set_hashedvalue(const char* value);
  inline void set_hashedvalue(const void* value, size_t size);
  inline ::std::string* mutable_hashedvalue();
  inline ::std::string* release_hashedvalue();
  inline void set_allocated_hashedvalue(::std::string* hashedvalue);

  // optional string partID = 5;
  inline bool has_partid() const;
  inline void clear_partid();
  static const int kPartIDFieldNumber = 5;
  inline const ::std::string& partid() const;
  inline void set_partid(const ::std::string& value);
  inline void set_partid(const char* value);
  inline void set_partid(const char* value, size_t size);
  inline ::std::string* mutable_partid();
  inline ::std::string* release_partid();
  inline void set_allocated_partid(::std::string* partid);

  // optional string remoteURL = 6;
  inline bool has_remoteurl() const;
  inline void clear_remoteurl();
  static const int kRemoteURLFieldNumber = 6;
  inline const ::std::string& remoteurl() const;
  inline void set_remoteurl(const ::std::string& value);
  inline void set_remoteurl(const char* value);
  inline void set_remoteurl(const char* value, size_t size);
  inline ::std::string* mutable_remoteurl();
  inline ::std::string* release_remoteurl();
  inline void set_allocated_remoteurl(::std::string* remoteurl);

  // optional bool isInline = 7 [default = false];
  inline bool has_isinline() const;
  inline void clear_isinline();
  static const int kIsInlineFieldNumber = 7;
  inline bool isinline() const;
  inline void set_isinline(bool value);

  // @@protoc_insertion_point(class_scope:mynigma.payloadPart.fileAttachment)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_contentid();
  inline void clear_has_contentid();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_hashedvalue();
  inline void clear_has_hashedvalue();
  inline void set_has_partid();
  inline void clear_has_partid();
  inline void set_has_remoteurl();
  inline void clear_has_remoteurl();
  inline void set_has_isinline();
  inline void clear_has_isinline();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::std::string* contentid_;
  ::std::string* hashedvalue_;
  ::std::string* partid_;
  ::google::protobuf::int32 size_;
  bool isinline_;
  ::std::string* remoteurl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static payloadPart_fileAttachment* default_instance_;
};
// -------------------------------------------------------------------

class payloadPart : public ::google::protobuf::Message {
 public:
  payloadPart();
  virtual ~payloadPart();

  payloadPart(const payloadPart& from);

  inline payloadPart& operator=(const payloadPart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const payloadPart& default_instance();

  void Swap(payloadPart* other);

  // implements Message ----------------------------------------------

  payloadPart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const payloadPart& from);
  void MergeFrom(const payloadPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef payloadPart_emailRecipient emailRecipient;
  typedef payloadPart_fileAttachment fileAttachment;

  typedef payloadPart_addresseeType addresseeType;
  static const addresseeType T_FROM = payloadPart_addresseeType_T_FROM;
  static const addresseeType T_REPLY_TO = payloadPart_addresseeType_T_REPLY_TO;
  static const addresseeType T_TO = payloadPart_addresseeType_T_TO;
  static const addresseeType T_CC = payloadPart_addresseeType_T_CC;
  static const addresseeType T_BCC = payloadPart_addresseeType_T_BCC;
  static inline bool addresseeType_IsValid(int value) {
    return payloadPart_addresseeType_IsValid(value);
  }
  static const addresseeType addresseeType_MIN =
    payloadPart_addresseeType_addresseeType_MIN;
  static const addresseeType addresseeType_MAX =
    payloadPart_addresseeType_addresseeType_MAX;
  static const int addresseeType_ARRAYSIZE =
    payloadPart_addresseeType_addresseeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  addresseeType_descriptor() {
    return payloadPart_addresseeType_descriptor();
  }
  static inline const ::std::string& addresseeType_Name(addresseeType value) {
    return payloadPart_addresseeType_Name(value);
  }
  static inline bool addresseeType_Parse(const ::std::string& name,
      addresseeType* value) {
    return payloadPart_addresseeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string body = 1;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 1;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const char* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional string htmlBody = 2;
  inline bool has_htmlbody() const;
  inline void clear_htmlbody();
  static const int kHtmlBodyFieldNumber = 2;
  inline const ::std::string& htmlbody() const;
  inline void set_htmlbody(const ::std::string& value);
  inline void set_htmlbody(const char* value);
  inline void set_htmlbody(const char* value, size_t size);
  inline ::std::string* mutable_htmlbody();
  inline ::std::string* release_htmlbody();
  inline void set_allocated_htmlbody(::std::string* htmlbody);

  // required string subject = 3;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 3;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional int32 dateSent = 4;
  inline bool has_datesent() const;
  inline void clear_datesent();
  static const int kDateSentFieldNumber = 4;
  inline ::google::protobuf::int32 datesent() const;
  inline void set_datesent(::google::protobuf::int32 value);

  // optional bytes declaration = 7;
  inline bool has_declaration() const;
  inline void clear_declaration();
  static const int kDeclarationFieldNumber = 7;
  inline const ::std::string& declaration() const;
  inline void set_declaration(const ::std::string& value);
  inline void set_declaration(const char* value);
  inline void set_declaration(const void* value, size_t size);
  inline ::std::string* mutable_declaration();
  inline ::std::string* release_declaration();
  inline void set_allocated_declaration(::std::string* declaration);

  // repeated .mynigma.payloadPart.emailRecipient recipients = 5;
  inline int recipients_size() const;
  inline void clear_recipients();
  static const int kRecipientsFieldNumber = 5;
  inline const ::mynigma::payloadPart_emailRecipient& recipients(int index) const;
  inline ::mynigma::payloadPart_emailRecipient* mutable_recipients(int index);
  inline ::mynigma::payloadPart_emailRecipient* add_recipients();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_emailRecipient >&
      recipients() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_emailRecipient >*
      mutable_recipients();

  // repeated .mynigma.payloadPart.fileAttachment attachments = 6;
  inline int attachments_size() const;
  inline void clear_attachments();
  static const int kAttachmentsFieldNumber = 6;
  inline const ::mynigma::payloadPart_fileAttachment& attachments(int index) const;
  inline ::mynigma::payloadPart_fileAttachment* mutable_attachments(int index);
  inline ::mynigma::payloadPart_fileAttachment* add_attachments();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_fileAttachment >&
      attachments() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_fileAttachment >*
      mutable_attachments();

  // @@protoc_insertion_point(class_scope:mynigma.payloadPart)
 private:
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_htmlbody();
  inline void clear_has_htmlbody();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_datesent();
  inline void clear_has_datesent();
  inline void set_has_declaration();
  inline void clear_has_declaration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* body_;
  ::std::string* htmlbody_;
  ::std::string* subject_;
  ::std::string* declaration_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_emailRecipient > recipients_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_fileAttachment > attachments_;
  ::google::protobuf::int32 datesent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mynigma_2eproto();
  friend void protobuf_AssignDesc_mynigma_2eproto();
  friend void protobuf_ShutdownFile_mynigma_2eproto();

  void InitAsDefaultInstance();
  static payloadPart* default_instance_;
};
// ===================================================================


// ===================================================================

// keyIntroduction

// optional string oldKeyLabel = 1;
inline bool keyIntroduction::has_oldkeylabel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void keyIntroduction::set_has_oldkeylabel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void keyIntroduction::clear_has_oldkeylabel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void keyIntroduction::clear_oldkeylabel() {
  if (oldkeylabel_ != &::google::protobuf::internal::kEmptyString) {
    oldkeylabel_->clear();
  }
  clear_has_oldkeylabel();
}
inline const ::std::string& keyIntroduction::oldkeylabel() const {
  return *oldkeylabel_;
}
inline void keyIntroduction::set_oldkeylabel(const ::std::string& value) {
  set_has_oldkeylabel();
  if (oldkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    oldkeylabel_ = new ::std::string;
  }
  oldkeylabel_->assign(value);
}
inline void keyIntroduction::set_oldkeylabel(const char* value) {
  set_has_oldkeylabel();
  if (oldkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    oldkeylabel_ = new ::std::string;
  }
  oldkeylabel_->assign(value);
}
inline void keyIntroduction::set_oldkeylabel(const char* value, size_t size) {
  set_has_oldkeylabel();
  if (oldkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    oldkeylabel_ = new ::std::string;
  }
  oldkeylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyIntroduction::mutable_oldkeylabel() {
  set_has_oldkeylabel();
  if (oldkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    oldkeylabel_ = new ::std::string;
  }
  return oldkeylabel_;
}
inline ::std::string* keyIntroduction::release_oldkeylabel() {
  clear_has_oldkeylabel();
  if (oldkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldkeylabel_;
    oldkeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyIntroduction::set_allocated_oldkeylabel(::std::string* oldkeylabel) {
  if (oldkeylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete oldkeylabel_;
  }
  if (oldkeylabel) {
    set_has_oldkeylabel();
    oldkeylabel_ = oldkeylabel;
  } else {
    clear_has_oldkeylabel();
    oldkeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string newKeyLabel = 2;
inline bool keyIntroduction::has_newkeylabel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void keyIntroduction::set_has_newkeylabel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void keyIntroduction::clear_has_newkeylabel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void keyIntroduction::clear_newkeylabel() {
  if (newkeylabel_ != &::google::protobuf::internal::kEmptyString) {
    newkeylabel_->clear();
  }
  clear_has_newkeylabel();
}
inline const ::std::string& keyIntroduction::newkeylabel() const {
  return *newkeylabel_;
}
inline void keyIntroduction::set_newkeylabel(const ::std::string& value) {
  set_has_newkeylabel();
  if (newkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    newkeylabel_ = new ::std::string;
  }
  newkeylabel_->assign(value);
}
inline void keyIntroduction::set_newkeylabel(const char* value) {
  set_has_newkeylabel();
  if (newkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    newkeylabel_ = new ::std::string;
  }
  newkeylabel_->assign(value);
}
inline void keyIntroduction::set_newkeylabel(const char* value, size_t size) {
  set_has_newkeylabel();
  if (newkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    newkeylabel_ = new ::std::string;
  }
  newkeylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyIntroduction::mutable_newkeylabel() {
  set_has_newkeylabel();
  if (newkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    newkeylabel_ = new ::std::string;
  }
  return newkeylabel_;
}
inline ::std::string* keyIntroduction::release_newkeylabel() {
  clear_has_newkeylabel();
  if (newkeylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newkeylabel_;
    newkeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyIntroduction::set_allocated_newkeylabel(::std::string* newkeylabel) {
  if (newkeylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete newkeylabel_;
  }
  if (newkeylabel) {
    set_has_newkeylabel();
    newkeylabel_ = newkeylabel;
  } else {
    clear_has_newkeylabel();
    newkeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes newEncKey = 3;
inline bool keyIntroduction::has_newenckey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void keyIntroduction::set_has_newenckey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void keyIntroduction::clear_has_newenckey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void keyIntroduction::clear_newenckey() {
  if (newenckey_ != &::google::protobuf::internal::kEmptyString) {
    newenckey_->clear();
  }
  clear_has_newenckey();
}
inline const ::std::string& keyIntroduction::newenckey() const {
  return *newenckey_;
}
inline void keyIntroduction::set_newenckey(const ::std::string& value) {
  set_has_newenckey();
  if (newenckey_ == &::google::protobuf::internal::kEmptyString) {
    newenckey_ = new ::std::string;
  }
  newenckey_->assign(value);
}
inline void keyIntroduction::set_newenckey(const char* value) {
  set_has_newenckey();
  if (newenckey_ == &::google::protobuf::internal::kEmptyString) {
    newenckey_ = new ::std::string;
  }
  newenckey_->assign(value);
}
inline void keyIntroduction::set_newenckey(const void* value, size_t size) {
  set_has_newenckey();
  if (newenckey_ == &::google::protobuf::internal::kEmptyString) {
    newenckey_ = new ::std::string;
  }
  newenckey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyIntroduction::mutable_newenckey() {
  set_has_newenckey();
  if (newenckey_ == &::google::protobuf::internal::kEmptyString) {
    newenckey_ = new ::std::string;
  }
  return newenckey_;
}
inline ::std::string* keyIntroduction::release_newenckey() {
  clear_has_newenckey();
  if (newenckey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newenckey_;
    newenckey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyIntroduction::set_allocated_newenckey(::std::string* newenckey) {
  if (newenckey_ != &::google::protobuf::internal::kEmptyString) {
    delete newenckey_;
  }
  if (newenckey) {
    set_has_newenckey();
    newenckey_ = newenckey;
  } else {
    clear_has_newenckey();
    newenckey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes newVerKey = 4;
inline bool keyIntroduction::has_newverkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void keyIntroduction::set_has_newverkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void keyIntroduction::clear_has_newverkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void keyIntroduction::clear_newverkey() {
  if (newverkey_ != &::google::protobuf::internal::kEmptyString) {
    newverkey_->clear();
  }
  clear_has_newverkey();
}
inline const ::std::string& keyIntroduction::newverkey() const {
  return *newverkey_;
}
inline void keyIntroduction::set_newverkey(const ::std::string& value) {
  set_has_newverkey();
  if (newverkey_ == &::google::protobuf::internal::kEmptyString) {
    newverkey_ = new ::std::string;
  }
  newverkey_->assign(value);
}
inline void keyIntroduction::set_newverkey(const char* value) {
  set_has_newverkey();
  if (newverkey_ == &::google::protobuf::internal::kEmptyString) {
    newverkey_ = new ::std::string;
  }
  newverkey_->assign(value);
}
inline void keyIntroduction::set_newverkey(const void* value, size_t size) {
  set_has_newverkey();
  if (newverkey_ == &::google::protobuf::internal::kEmptyString) {
    newverkey_ = new ::std::string;
  }
  newverkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyIntroduction::mutable_newverkey() {
  set_has_newverkey();
  if (newverkey_ == &::google::protobuf::internal::kEmptyString) {
    newverkey_ = new ::std::string;
  }
  return newverkey_;
}
inline ::std::string* keyIntroduction::release_newverkey() {
  clear_has_newverkey();
  if (newverkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newverkey_;
    newverkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyIntroduction::set_allocated_newverkey(::std::string* newverkey) {
  if (newverkey_ != &::google::protobuf::internal::kEmptyString) {
    delete newverkey_;
  }
  if (newverkey) {
    set_has_newverkey();
    newverkey_ = newverkey;
  } else {
    clear_has_newverkey();
    newverkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 5;
inline bool keyIntroduction::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void keyIntroduction::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void keyIntroduction::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void keyIntroduction::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& keyIntroduction::signature() const {
  return *signature_;
}
inline void keyIntroduction::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void keyIntroduction::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void keyIntroduction::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyIntroduction::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* keyIntroduction::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyIntroduction::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 6;
inline bool keyIntroduction::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void keyIntroduction::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void keyIntroduction::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void keyIntroduction::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& keyIntroduction::version() const {
  return *version_;
}
inline void keyIntroduction::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void keyIntroduction::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void keyIntroduction::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyIntroduction::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* keyIntroduction::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyIntroduction::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateSigned = 7;
inline bool keyIntroduction::has_datesigned() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void keyIntroduction::set_has_datesigned() {
  _has_bits_[0] |= 0x00000040u;
}
inline void keyIntroduction::clear_has_datesigned() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void keyIntroduction::clear_datesigned() {
  datesigned_ = 0;
  clear_has_datesigned();
}
inline ::google::protobuf::int32 keyIntroduction::datesigned() const {
  return datesigned_;
}
inline void keyIntroduction::set_datesigned(::google::protobuf::int32 value) {
  set_has_datesigned();
  datesigned_ = value;
}

// -------------------------------------------------------------------

// encrSessionKeyEntry

// required string keyLabel = 1;
inline bool encrSessionKeyEntry::has_keylabel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void encrSessionKeyEntry::set_has_keylabel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void encrSessionKeyEntry::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void encrSessionKeyEntry::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& encrSessionKeyEntry::keylabel() const {
  return *keylabel_;
}
inline void encrSessionKeyEntry::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void encrSessionKeyEntry::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void encrSessionKeyEntry::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encrSessionKeyEntry::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* encrSessionKeyEntry::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void encrSessionKeyEntry::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes encrSessionKey = 2;
inline bool encrSessionKeyEntry::has_encrsessionkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void encrSessionKeyEntry::set_has_encrsessionkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void encrSessionKeyEntry::clear_has_encrsessionkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void encrSessionKeyEntry::clear_encrsessionkey() {
  if (encrsessionkey_ != &::google::protobuf::internal::kEmptyString) {
    encrsessionkey_->clear();
  }
  clear_has_encrsessionkey();
}
inline const ::std::string& encrSessionKeyEntry::encrsessionkey() const {
  return *encrsessionkey_;
}
inline void encrSessionKeyEntry::set_encrsessionkey(const ::std::string& value) {
  set_has_encrsessionkey();
  if (encrsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encrsessionkey_ = new ::std::string;
  }
  encrsessionkey_->assign(value);
}
inline void encrSessionKeyEntry::set_encrsessionkey(const char* value) {
  set_has_encrsessionkey();
  if (encrsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encrsessionkey_ = new ::std::string;
  }
  encrsessionkey_->assign(value);
}
inline void encrSessionKeyEntry::set_encrsessionkey(const void* value, size_t size) {
  set_has_encrsessionkey();
  if (encrsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encrsessionkey_ = new ::std::string;
  }
  encrsessionkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encrSessionKeyEntry::mutable_encrsessionkey() {
  set_has_encrsessionkey();
  if (encrsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encrsessionkey_ = new ::std::string;
  }
  return encrsessionkey_;
}
inline ::std::string* encrSessionKeyEntry::release_encrsessionkey() {
  clear_has_encrsessionkey();
  if (encrsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrsessionkey_;
    encrsessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void encrSessionKeyEntry::set_allocated_encrsessionkey(::std::string* encrsessionkey) {
  if (encrsessionkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encrsessionkey_;
  }
  if (encrsessionkey) {
    set_has_encrsessionkey();
    encrsessionkey_ = encrsessionkey;
  } else {
    clear_has_encrsessionkey();
    encrsessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes introductionData = 3;
inline bool encrSessionKeyEntry::has_introductiondata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void encrSessionKeyEntry::set_has_introductiondata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void encrSessionKeyEntry::clear_has_introductiondata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void encrSessionKeyEntry::clear_introductiondata() {
  if (introductiondata_ != &::google::protobuf::internal::kEmptyString) {
    introductiondata_->clear();
  }
  clear_has_introductiondata();
}
inline const ::std::string& encrSessionKeyEntry::introductiondata() const {
  return *introductiondata_;
}
inline void encrSessionKeyEntry::set_introductiondata(const ::std::string& value) {
  set_has_introductiondata();
  if (introductiondata_ == &::google::protobuf::internal::kEmptyString) {
    introductiondata_ = new ::std::string;
  }
  introductiondata_->assign(value);
}
inline void encrSessionKeyEntry::set_introductiondata(const char* value) {
  set_has_introductiondata();
  if (introductiondata_ == &::google::protobuf::internal::kEmptyString) {
    introductiondata_ = new ::std::string;
  }
  introductiondata_->assign(value);
}
inline void encrSessionKeyEntry::set_introductiondata(const void* value, size_t size) {
  set_has_introductiondata();
  if (introductiondata_ == &::google::protobuf::internal::kEmptyString) {
    introductiondata_ = new ::std::string;
  }
  introductiondata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encrSessionKeyEntry::mutable_introductiondata() {
  set_has_introductiondata();
  if (introductiondata_ == &::google::protobuf::internal::kEmptyString) {
    introductiondata_ = new ::std::string;
  }
  return introductiondata_;
}
inline ::std::string* encrSessionKeyEntry::release_introductiondata() {
  clear_has_introductiondata();
  if (introductiondata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = introductiondata_;
    introductiondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void encrSessionKeyEntry::set_allocated_introductiondata(::std::string* introductiondata) {
  if (introductiondata_ != &::google::protobuf::internal::kEmptyString) {
    delete introductiondata_;
  }
  if (introductiondata) {
    set_has_introductiondata();
    introductiondata_ = introductiondata;
  } else {
    clear_has_introductiondata();
    introductiondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// versionData

// required string version = 3;
inline bool versionData::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void versionData::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void versionData::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void versionData::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& versionData::version() const {
  return *version_;
}
inline void versionData::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void versionData::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void versionData::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* versionData::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* versionData::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void versionData::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HMACData

// required bytes encryptedData = 1;
inline bool HMACData::has_encrypteddata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HMACData::set_has_encrypteddata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HMACData::clear_has_encrypteddata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HMACData::clear_encrypteddata() {
  if (encrypteddata_ != &::google::protobuf::internal::kEmptyString) {
    encrypteddata_->clear();
  }
  clear_has_encrypteddata();
}
inline const ::std::string& HMACData::encrypteddata() const {
  return *encrypteddata_;
}
inline void HMACData::set_encrypteddata(const ::std::string& value) {
  set_has_encrypteddata();
  if (encrypteddata_ == &::google::protobuf::internal::kEmptyString) {
    encrypteddata_ = new ::std::string;
  }
  encrypteddata_->assign(value);
}
inline void HMACData::set_encrypteddata(const char* value) {
  set_has_encrypteddata();
  if (encrypteddata_ == &::google::protobuf::internal::kEmptyString) {
    encrypteddata_ = new ::std::string;
  }
  encrypteddata_->assign(value);
}
inline void HMACData::set_encrypteddata(const void* value, size_t size) {
  set_has_encrypteddata();
  if (encrypteddata_ == &::google::protobuf::internal::kEmptyString) {
    encrypteddata_ = new ::std::string;
  }
  encrypteddata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HMACData::mutable_encrypteddata() {
  set_has_encrypteddata();
  if (encrypteddata_ == &::google::protobuf::internal::kEmptyString) {
    encrypteddata_ = new ::std::string;
  }
  return encrypteddata_;
}
inline ::std::string* HMACData::release_encrypteddata() {
  clear_has_encrypteddata();
  if (encrypteddata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypteddata_;
    encrypteddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HMACData::set_allocated_encrypteddata(::std::string* encrypteddata) {
  if (encrypteddata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypteddata_;
  }
  if (encrypteddata) {
    set_has_encrypteddata();
    encrypteddata_ = encrypteddata;
  } else {
    clear_has_encrypteddata();
    encrypteddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes HMAC = 2;
inline bool HMACData::has_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HMACData::set_has_hmac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HMACData::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HMACData::clear_hmac() {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    hmac_->clear();
  }
  clear_has_hmac();
}
inline const ::std::string& HMACData::hmac() const {
  return *hmac_;
}
inline void HMACData::set_hmac(const ::std::string& value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void HMACData::set_hmac(const char* value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void HMACData::set_hmac(const void* value, size_t size) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HMACData::mutable_hmac() {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  return hmac_;
}
inline ::std::string* HMACData::release_hmac() {
  clear_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hmac_;
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HMACData::set_allocated_hmac(::std::string* hmac) {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_;
  }
  if (hmac) {
    set_has_hmac();
    hmac_ = hmac;
  } else {
    clear_has_hmac();
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string version = 3;
inline bool HMACData::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HMACData::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HMACData::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HMACData::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& HMACData::version() const {
  return *version_;
}
inline void HMACData::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void HMACData::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void HMACData::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HMACData::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* HMACData::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HMACData::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// encryptedData

// required bytes encrMessageData = 1;
inline bool encryptedData::has_encrmessagedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void encryptedData::set_has_encrmessagedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void encryptedData::clear_has_encrmessagedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void encryptedData::clear_encrmessagedata() {
  if (encrmessagedata_ != &::google::protobuf::internal::kEmptyString) {
    encrmessagedata_->clear();
  }
  clear_has_encrmessagedata();
}
inline const ::std::string& encryptedData::encrmessagedata() const {
  return *encrmessagedata_;
}
inline void encryptedData::set_encrmessagedata(const ::std::string& value) {
  set_has_encrmessagedata();
  if (encrmessagedata_ == &::google::protobuf::internal::kEmptyString) {
    encrmessagedata_ = new ::std::string;
  }
  encrmessagedata_->assign(value);
}
inline void encryptedData::set_encrmessagedata(const char* value) {
  set_has_encrmessagedata();
  if (encrmessagedata_ == &::google::protobuf::internal::kEmptyString) {
    encrmessagedata_ = new ::std::string;
  }
  encrmessagedata_->assign(value);
}
inline void encryptedData::set_encrmessagedata(const void* value, size_t size) {
  set_has_encrmessagedata();
  if (encrmessagedata_ == &::google::protobuf::internal::kEmptyString) {
    encrmessagedata_ = new ::std::string;
  }
  encrmessagedata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encryptedData::mutable_encrmessagedata() {
  set_has_encrmessagedata();
  if (encrmessagedata_ == &::google::protobuf::internal::kEmptyString) {
    encrmessagedata_ = new ::std::string;
  }
  return encrmessagedata_;
}
inline ::std::string* encryptedData::release_encrmessagedata() {
  clear_has_encrmessagedata();
  if (encrmessagedata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrmessagedata_;
    encrmessagedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void encryptedData::set_allocated_encrmessagedata(::std::string* encrmessagedata) {
  if (encrmessagedata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrmessagedata_;
  }
  if (encrmessagedata) {
    set_has_encrmessagedata();
    encrmessagedata_ = encrmessagedata;
  } else {
    clear_has_encrmessagedata();
    encrmessagedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mynigma.encrSessionKeyEntry encrSessionKeyTable = 2;
inline int encryptedData::encrsessionkeytable_size() const {
  return encrsessionkeytable_.size();
}
inline void encryptedData::clear_encrsessionkeytable() {
  encrsessionkeytable_.Clear();
}
inline const ::mynigma::encrSessionKeyEntry& encryptedData::encrsessionkeytable(int index) const {
  return encrsessionkeytable_.Get(index);
}
inline ::mynigma::encrSessionKeyEntry* encryptedData::mutable_encrsessionkeytable(int index) {
  return encrsessionkeytable_.Mutable(index);
}
inline ::mynigma::encrSessionKeyEntry* encryptedData::add_encrsessionkeytable() {
  return encrsessionkeytable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::encrSessionKeyEntry >&
encryptedData::encrsessionkeytable() const {
  return encrsessionkeytable_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::encrSessionKeyEntry >*
encryptedData::mutable_encrsessionkeytable() {
  return &encrsessionkeytable_;
}

// optional string version = 3;
inline bool encryptedData::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void encryptedData::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void encryptedData::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void encryptedData::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& encryptedData::version() const {
  return *version_;
}
inline void encryptedData::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void encryptedData::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void encryptedData::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encryptedData::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* encryptedData::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void encryptedData::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string info = 4;
inline bool encryptedData::has_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void encryptedData::set_has_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void encryptedData::clear_has_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void encryptedData::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& encryptedData::info() const {
  return *info_;
}
inline void encryptedData::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void encryptedData::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void encryptedData::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encryptedData::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* encryptedData::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void encryptedData::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes encrAttachmentData = 5;
inline int encryptedData::encrattachmentdata_size() const {
  return encrattachmentdata_.size();
}
inline void encryptedData::clear_encrattachmentdata() {
  encrattachmentdata_.Clear();
}
inline const ::std::string& encryptedData::encrattachmentdata(int index) const {
  return encrattachmentdata_.Get(index);
}
inline ::std::string* encryptedData::mutable_encrattachmentdata(int index) {
  return encrattachmentdata_.Mutable(index);
}
inline void encryptedData::set_encrattachmentdata(int index, const ::std::string& value) {
  encrattachmentdata_.Mutable(index)->assign(value);
}
inline void encryptedData::set_encrattachmentdata(int index, const char* value) {
  encrattachmentdata_.Mutable(index)->assign(value);
}
inline void encryptedData::set_encrattachmentdata(int index, const void* value, size_t size) {
  encrattachmentdata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encryptedData::add_encrattachmentdata() {
  return encrattachmentdata_.Add();
}
inline void encryptedData::add_encrattachmentdata(const ::std::string& value) {
  encrattachmentdata_.Add()->assign(value);
}
inline void encryptedData::add_encrattachmentdata(const char* value) {
  encrattachmentdata_.Add()->assign(value);
}
inline void encryptedData::add_encrattachmentdata(const void* value, size_t size) {
  encrattachmentdata_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
encryptedData::encrattachmentdata() const {
  return encrattachmentdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
encryptedData::mutable_encrattachmentdata() {
  return &encrattachmentdata_;
}

// repeated bytes attachmentsHMAC = 6;
inline int encryptedData::attachmentshmac_size() const {
  return attachmentshmac_.size();
}
inline void encryptedData::clear_attachmentshmac() {
  attachmentshmac_.Clear();
}
inline const ::std::string& encryptedData::attachmentshmac(int index) const {
  return attachmentshmac_.Get(index);
}
inline ::std::string* encryptedData::mutable_attachmentshmac(int index) {
  return attachmentshmac_.Mutable(index);
}
inline void encryptedData::set_attachmentshmac(int index, const ::std::string& value) {
  attachmentshmac_.Mutable(index)->assign(value);
}
inline void encryptedData::set_attachmentshmac(int index, const char* value) {
  attachmentshmac_.Mutable(index)->assign(value);
}
inline void encryptedData::set_attachmentshmac(int index, const void* value, size_t size) {
  attachmentshmac_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encryptedData::add_attachmentshmac() {
  return attachmentshmac_.Add();
}
inline void encryptedData::add_attachmentshmac(const ::std::string& value) {
  attachmentshmac_.Add()->assign(value);
}
inline void encryptedData::add_attachmentshmac(const char* value) {
  attachmentshmac_.Add()->assign(value);
}
inline void encryptedData::add_attachmentshmac(const void* value, size_t size) {
  attachmentshmac_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
encryptedData::attachmentshmac() const {
  return attachmentshmac_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
encryptedData::mutable_attachmentshmac() {
  return &attachmentshmac_;
}

// optional bytes messageHMAC = 7;
inline bool encryptedData::has_messagehmac() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void encryptedData::set_has_messagehmac() {
  _has_bits_[0] |= 0x00000040u;
}
inline void encryptedData::clear_has_messagehmac() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void encryptedData::clear_messagehmac() {
  if (messagehmac_ != &::google::protobuf::internal::kEmptyString) {
    messagehmac_->clear();
  }
  clear_has_messagehmac();
}
inline const ::std::string& encryptedData::messagehmac() const {
  return *messagehmac_;
}
inline void encryptedData::set_messagehmac(const ::std::string& value) {
  set_has_messagehmac();
  if (messagehmac_ == &::google::protobuf::internal::kEmptyString) {
    messagehmac_ = new ::std::string;
  }
  messagehmac_->assign(value);
}
inline void encryptedData::set_messagehmac(const char* value) {
  set_has_messagehmac();
  if (messagehmac_ == &::google::protobuf::internal::kEmptyString) {
    messagehmac_ = new ::std::string;
  }
  messagehmac_->assign(value);
}
inline void encryptedData::set_messagehmac(const void* value, size_t size) {
  set_has_messagehmac();
  if (messagehmac_ == &::google::protobuf::internal::kEmptyString) {
    messagehmac_ = new ::std::string;
  }
  messagehmac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* encryptedData::mutable_messagehmac() {
  set_has_messagehmac();
  if (messagehmac_ == &::google::protobuf::internal::kEmptyString) {
    messagehmac_ = new ::std::string;
  }
  return messagehmac_;
}
inline ::std::string* encryptedData::release_messagehmac() {
  clear_has_messagehmac();
  if (messagehmac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messagehmac_;
    messagehmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void encryptedData::set_allocated_messagehmac(::std::string* messagehmac) {
  if (messagehmac_ != &::google::protobuf::internal::kEmptyString) {
    delete messagehmac_;
  }
  if (messagehmac) {
    set_has_messagehmac();
    messagehmac_ = messagehmac;
  } else {
    clear_has_messagehmac();
    messagehmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// signedData

// optional string keyLabel = 1;
inline bool signedData::has_keylabel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void signedData::set_has_keylabel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void signedData::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void signedData::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& signedData::keylabel() const {
  return *keylabel_;
}
inline void signedData::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void signedData::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void signedData::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* signedData::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* signedData::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void signedData::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 2;
inline bool signedData::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void signedData::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void signedData::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void signedData::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& signedData::signature() const {
  return *signature_;
}
inline void signedData::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void signedData::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void signedData::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* signedData::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* signedData::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void signedData::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes data = 3;
inline bool signedData::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void signedData::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void signedData::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void signedData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& signedData::data() const {
  return *data_;
}
inline void signedData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void signedData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void signedData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* signedData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* signedData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void signedData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 4;
inline bool signedData::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void signedData::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void signedData::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void signedData::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& signedData::version() const {
  return *version_;
}
inline void signedData::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void signedData::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void signedData::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* signedData::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* signedData::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void signedData::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// payloadPart_emailRecipient

// optional string name = 1;
inline bool payloadPart_emailRecipient::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void payloadPart_emailRecipient::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void payloadPart_emailRecipient::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void payloadPart_emailRecipient::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& payloadPart_emailRecipient::name() const {
  return *name_;
}
inline void payloadPart_emailRecipient::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void payloadPart_emailRecipient::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void payloadPart_emailRecipient::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart_emailRecipient::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* payloadPart_emailRecipient::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart_emailRecipient::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 2;
inline bool payloadPart_emailRecipient::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void payloadPart_emailRecipient::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void payloadPart_emailRecipient::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void payloadPart_emailRecipient::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& payloadPart_emailRecipient::email() const {
  return *email_;
}
inline void payloadPart_emailRecipient::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void payloadPart_emailRecipient::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void payloadPart_emailRecipient::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart_emailRecipient::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* payloadPart_emailRecipient::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart_emailRecipient::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mynigma.payloadPart.addresseeType type = 3 [default = T_TO];
inline bool payloadPart_emailRecipient::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void payloadPart_emailRecipient::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void payloadPart_emailRecipient::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void payloadPart_emailRecipient::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::mynigma::payloadPart_addresseeType payloadPart_emailRecipient::type() const {
  return static_cast< ::mynigma::payloadPart_addresseeType >(type_);
}
inline void payloadPart_emailRecipient::set_type(::mynigma::payloadPart_addresseeType value) {
  assert(::mynigma::payloadPart_addresseeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// payloadPart_fileAttachment

// optional string filename = 1;
inline bool payloadPart_fileAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void payloadPart_fileAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void payloadPart_fileAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void payloadPart_fileAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& payloadPart_fileAttachment::filename() const {
  return *filename_;
}
inline void payloadPart_fileAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void payloadPart_fileAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void payloadPart_fileAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart_fileAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* payloadPart_fileAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart_fileAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string contentID = 2;
inline bool payloadPart_fileAttachment::has_contentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void payloadPart_fileAttachment::set_has_contentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void payloadPart_fileAttachment::clear_has_contentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void payloadPart_fileAttachment::clear_contentid() {
  if (contentid_ != &::google::protobuf::internal::kEmptyString) {
    contentid_->clear();
  }
  clear_has_contentid();
}
inline const ::std::string& payloadPart_fileAttachment::contentid() const {
  return *contentid_;
}
inline void payloadPart_fileAttachment::set_contentid(const ::std::string& value) {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  contentid_->assign(value);
}
inline void payloadPart_fileAttachment::set_contentid(const char* value) {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  contentid_->assign(value);
}
inline void payloadPart_fileAttachment::set_contentid(const char* value, size_t size) {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  contentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart_fileAttachment::mutable_contentid() {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  return contentid_;
}
inline ::std::string* payloadPart_fileAttachment::release_contentid() {
  clear_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contentid_;
    contentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart_fileAttachment::set_allocated_contentid(::std::string* contentid) {
  if (contentid_ != &::google::protobuf::internal::kEmptyString) {
    delete contentid_;
  }
  if (contentid) {
    set_has_contentid();
    contentid_ = contentid;
  } else {
    clear_has_contentid();
    contentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 size = 3;
inline bool payloadPart_fileAttachment::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void payloadPart_fileAttachment::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void payloadPart_fileAttachment::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void payloadPart_fileAttachment::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 payloadPart_fileAttachment::size() const {
  return size_;
}
inline void payloadPart_fileAttachment::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional bytes hashedValue = 4;
inline bool payloadPart_fileAttachment::has_hashedvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void payloadPart_fileAttachment::set_has_hashedvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void payloadPart_fileAttachment::clear_has_hashedvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void payloadPart_fileAttachment::clear_hashedvalue() {
  if (hashedvalue_ != &::google::protobuf::internal::kEmptyString) {
    hashedvalue_->clear();
  }
  clear_has_hashedvalue();
}
inline const ::std::string& payloadPart_fileAttachment::hashedvalue() const {
  return *hashedvalue_;
}
inline void payloadPart_fileAttachment::set_hashedvalue(const ::std::string& value) {
  set_has_hashedvalue();
  if (hashedvalue_ == &::google::protobuf::internal::kEmptyString) {
    hashedvalue_ = new ::std::string;
  }
  hashedvalue_->assign(value);
}
inline void payloadPart_fileAttachment::set_hashedvalue(const char* value) {
  set_has_hashedvalue();
  if (hashedvalue_ == &::google::protobuf::internal::kEmptyString) {
    hashedvalue_ = new ::std::string;
  }
  hashedvalue_->assign(value);
}
inline void payloadPart_fileAttachment::set_hashedvalue(const void* value, size_t size) {
  set_has_hashedvalue();
  if (hashedvalue_ == &::google::protobuf::internal::kEmptyString) {
    hashedvalue_ = new ::std::string;
  }
  hashedvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart_fileAttachment::mutable_hashedvalue() {
  set_has_hashedvalue();
  if (hashedvalue_ == &::google::protobuf::internal::kEmptyString) {
    hashedvalue_ = new ::std::string;
  }
  return hashedvalue_;
}
inline ::std::string* payloadPart_fileAttachment::release_hashedvalue() {
  clear_has_hashedvalue();
  if (hashedvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hashedvalue_;
    hashedvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart_fileAttachment::set_allocated_hashedvalue(::std::string* hashedvalue) {
  if (hashedvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete hashedvalue_;
  }
  if (hashedvalue) {
    set_has_hashedvalue();
    hashedvalue_ = hashedvalue;
  } else {
    clear_has_hashedvalue();
    hashedvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string partID = 5;
inline bool payloadPart_fileAttachment::has_partid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void payloadPart_fileAttachment::set_has_partid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void payloadPart_fileAttachment::clear_has_partid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void payloadPart_fileAttachment::clear_partid() {
  if (partid_ != &::google::protobuf::internal::kEmptyString) {
    partid_->clear();
  }
  clear_has_partid();
}
inline const ::std::string& payloadPart_fileAttachment::partid() const {
  return *partid_;
}
inline void payloadPart_fileAttachment::set_partid(const ::std::string& value) {
  set_has_partid();
  if (partid_ == &::google::protobuf::internal::kEmptyString) {
    partid_ = new ::std::string;
  }
  partid_->assign(value);
}
inline void payloadPart_fileAttachment::set_partid(const char* value) {
  set_has_partid();
  if (partid_ == &::google::protobuf::internal::kEmptyString) {
    partid_ = new ::std::string;
  }
  partid_->assign(value);
}
inline void payloadPart_fileAttachment::set_partid(const char* value, size_t size) {
  set_has_partid();
  if (partid_ == &::google::protobuf::internal::kEmptyString) {
    partid_ = new ::std::string;
  }
  partid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart_fileAttachment::mutable_partid() {
  set_has_partid();
  if (partid_ == &::google::protobuf::internal::kEmptyString) {
    partid_ = new ::std::string;
  }
  return partid_;
}
inline ::std::string* payloadPart_fileAttachment::release_partid() {
  clear_has_partid();
  if (partid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partid_;
    partid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart_fileAttachment::set_allocated_partid(::std::string* partid) {
  if (partid_ != &::google::protobuf::internal::kEmptyString) {
    delete partid_;
  }
  if (partid) {
    set_has_partid();
    partid_ = partid;
  } else {
    clear_has_partid();
    partid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string remoteURL = 6;
inline bool payloadPart_fileAttachment::has_remoteurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void payloadPart_fileAttachment::set_has_remoteurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void payloadPart_fileAttachment::clear_has_remoteurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void payloadPart_fileAttachment::clear_remoteurl() {
  if (remoteurl_ != &::google::protobuf::internal::kEmptyString) {
    remoteurl_->clear();
  }
  clear_has_remoteurl();
}
inline const ::std::string& payloadPart_fileAttachment::remoteurl() const {
  return *remoteurl_;
}
inline void payloadPart_fileAttachment::set_remoteurl(const ::std::string& value) {
  set_has_remoteurl();
  if (remoteurl_ == &::google::protobuf::internal::kEmptyString) {
    remoteurl_ = new ::std::string;
  }
  remoteurl_->assign(value);
}
inline void payloadPart_fileAttachment::set_remoteurl(const char* value) {
  set_has_remoteurl();
  if (remoteurl_ == &::google::protobuf::internal::kEmptyString) {
    remoteurl_ = new ::std::string;
  }
  remoteurl_->assign(value);
}
inline void payloadPart_fileAttachment::set_remoteurl(const char* value, size_t size) {
  set_has_remoteurl();
  if (remoteurl_ == &::google::protobuf::internal::kEmptyString) {
    remoteurl_ = new ::std::string;
  }
  remoteurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart_fileAttachment::mutable_remoteurl() {
  set_has_remoteurl();
  if (remoteurl_ == &::google::protobuf::internal::kEmptyString) {
    remoteurl_ = new ::std::string;
  }
  return remoteurl_;
}
inline ::std::string* payloadPart_fileAttachment::release_remoteurl() {
  clear_has_remoteurl();
  if (remoteurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remoteurl_;
    remoteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart_fileAttachment::set_allocated_remoteurl(::std::string* remoteurl) {
  if (remoteurl_ != &::google::protobuf::internal::kEmptyString) {
    delete remoteurl_;
  }
  if (remoteurl) {
    set_has_remoteurl();
    remoteurl_ = remoteurl;
  } else {
    clear_has_remoteurl();
    remoteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isInline = 7 [default = false];
inline bool payloadPart_fileAttachment::has_isinline() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void payloadPart_fileAttachment::set_has_isinline() {
  _has_bits_[0] |= 0x00000040u;
}
inline void payloadPart_fileAttachment::clear_has_isinline() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void payloadPart_fileAttachment::clear_isinline() {
  isinline_ = false;
  clear_has_isinline();
}
inline bool payloadPart_fileAttachment::isinline() const {
  return isinline_;
}
inline void payloadPart_fileAttachment::set_isinline(bool value) {
  set_has_isinline();
  isinline_ = value;
}

// -------------------------------------------------------------------

// payloadPart

// optional string body = 1;
inline bool payloadPart::has_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void payloadPart::set_has_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void payloadPart::clear_has_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void payloadPart::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& payloadPart::body() const {
  return *body_;
}
inline void payloadPart::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void payloadPart::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void payloadPart::set_body(const char* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* payloadPart::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string htmlBody = 2;
inline bool payloadPart::has_htmlbody() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void payloadPart::set_has_htmlbody() {
  _has_bits_[0] |= 0x00000002u;
}
inline void payloadPart::clear_has_htmlbody() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void payloadPart::clear_htmlbody() {
  if (htmlbody_ != &::google::protobuf::internal::kEmptyString) {
    htmlbody_->clear();
  }
  clear_has_htmlbody();
}
inline const ::std::string& payloadPart::htmlbody() const {
  return *htmlbody_;
}
inline void payloadPart::set_htmlbody(const ::std::string& value) {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  htmlbody_->assign(value);
}
inline void payloadPart::set_htmlbody(const char* value) {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  htmlbody_->assign(value);
}
inline void payloadPart::set_htmlbody(const char* value, size_t size) {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  htmlbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart::mutable_htmlbody() {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  return htmlbody_;
}
inline ::std::string* payloadPart::release_htmlbody() {
  clear_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = htmlbody_;
    htmlbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart::set_allocated_htmlbody(::std::string* htmlbody) {
  if (htmlbody_ != &::google::protobuf::internal::kEmptyString) {
    delete htmlbody_;
  }
  if (htmlbody) {
    set_has_htmlbody();
    htmlbody_ = htmlbody;
  } else {
    clear_has_htmlbody();
    htmlbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string subject = 3;
inline bool payloadPart::has_subject() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void payloadPart::set_has_subject() {
  _has_bits_[0] |= 0x00000004u;
}
inline void payloadPart::clear_has_subject() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void payloadPart::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& payloadPart::subject() const {
  return *subject_;
}
inline void payloadPart::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void payloadPart::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void payloadPart::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* payloadPart::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateSent = 4;
inline bool payloadPart::has_datesent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void payloadPart::set_has_datesent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void payloadPart::clear_has_datesent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void payloadPart::clear_datesent() {
  datesent_ = 0;
  clear_has_datesent();
}
inline ::google::protobuf::int32 payloadPart::datesent() const {
  return datesent_;
}
inline void payloadPart::set_datesent(::google::protobuf::int32 value) {
  set_has_datesent();
  datesent_ = value;
}

// optional bytes declaration = 7;
inline bool payloadPart::has_declaration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void payloadPart::set_has_declaration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void payloadPart::clear_has_declaration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void payloadPart::clear_declaration() {
  if (declaration_ != &::google::protobuf::internal::kEmptyString) {
    declaration_->clear();
  }
  clear_has_declaration();
}
inline const ::std::string& payloadPart::declaration() const {
  return *declaration_;
}
inline void payloadPart::set_declaration(const ::std::string& value) {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  declaration_->assign(value);
}
inline void payloadPart::set_declaration(const char* value) {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  declaration_->assign(value);
}
inline void payloadPart::set_declaration(const void* value, size_t size) {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  declaration_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* payloadPart::mutable_declaration() {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  return declaration_;
}
inline ::std::string* payloadPart::release_declaration() {
  clear_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = declaration_;
    declaration_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void payloadPart::set_allocated_declaration(::std::string* declaration) {
  if (declaration_ != &::google::protobuf::internal::kEmptyString) {
    delete declaration_;
  }
  if (declaration) {
    set_has_declaration();
    declaration_ = declaration;
  } else {
    clear_has_declaration();
    declaration_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mynigma.payloadPart.emailRecipient recipients = 5;
inline int payloadPart::recipients_size() const {
  return recipients_.size();
}
inline void payloadPart::clear_recipients() {
  recipients_.Clear();
}
inline const ::mynigma::payloadPart_emailRecipient& payloadPart::recipients(int index) const {
  return recipients_.Get(index);
}
inline ::mynigma::payloadPart_emailRecipient* payloadPart::mutable_recipients(int index) {
  return recipients_.Mutable(index);
}
inline ::mynigma::payloadPart_emailRecipient* payloadPart::add_recipients() {
  return recipients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_emailRecipient >&
payloadPart::recipients() const {
  return recipients_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_emailRecipient >*
payloadPart::mutable_recipients() {
  return &recipients_;
}

// repeated .mynigma.payloadPart.fileAttachment attachments = 6;
inline int payloadPart::attachments_size() const {
  return attachments_.size();
}
inline void payloadPart::clear_attachments() {
  attachments_.Clear();
}
inline const ::mynigma::payloadPart_fileAttachment& payloadPart::attachments(int index) const {
  return attachments_.Get(index);
}
inline ::mynigma::payloadPart_fileAttachment* payloadPart::mutable_attachments(int index) {
  return attachments_.Mutable(index);
}
inline ::mynigma::payloadPart_fileAttachment* payloadPart::add_attachments() {
  return attachments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_fileAttachment >&
payloadPart::attachments() const {
  return attachments_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::payloadPart_fileAttachment >*
payloadPart::mutable_attachments() {
  return &attachments_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mynigma

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mynigma::payloadPart_addresseeType>() {
  return ::mynigma::payloadPart_addresseeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mynigma_2eproto__INCLUDED
